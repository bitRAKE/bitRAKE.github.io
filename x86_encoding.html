<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>x86-64 Encoding Atlas — Legacy · VEX · EVEX · XOP</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg:      #040710;
    --border:  #0d1526;
    --font:    'JetBrains Mono', 'Fira Code', monospace;
  }

  body {
    background: var(--bg);
    color: #dde3ec;
    font-family: var(--font);
    min-height: 100vh;
  }

  /* ── Header ─────────────────────────────────────────────── */
  #header {
    padding: 14px 22px 12px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 16px;
  }
  #header h1 { font-size: 13px; font-weight: 700; letter-spacing: .03em; }
  #header p  { font-size: 8.5px; margin-top: 3px; letter-spacing: .08em; color: #2a3a50; }

  #legend {
    margin-left: auto;
    display: flex;
    gap: 14px;
    align-items: center;
    flex-wrap: wrap;
  }
  .legend-item { display: flex; align-items: center; gap: 5px; }
  .legend-dot  { width: 7px; height: 7px; border-radius: 1.5px; }
  .legend-label{ font-size: 8.5px; letter-spacing: .07em; }

  /* ── Diagram wrapper ─────────────────────────────────────── */
  #diagram { overflow-x: auto; }
  #diagram-inner { min-width: 820px; padding: 0 12px 12px; }

  /* Column header bar */
  #col-headers {
    display: grid;
    grid-template-columns: 162px 214px 84px 78px 72px 78px 82px auto;
    padding: 7px 8px 4px;
    min-width: 820px;
  }
  .col-hdr {
    font-size: 7.5px;
    font-weight: 700;
    letter-spacing: 1px;
    color: #182233;
    text-align: center;
  }

  /* ── Group divider ───────────────────────────────────────── */
  .group-divider {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 0 4px;
  }
  .group-divider .line { flex: 1; height: 1px; }
  .group-divider .label {
    font-size: 7.5px;
    font-weight: 700;
    letter-spacing: 2px;
    opacity: .55;
  }

  /* ── Row ─────────────────────────────────────────────────── */
  .row-wrap { position: relative; }

  .row-svg-wrap {
    cursor: pointer;
    user-select: none;
  }
  .row-svg-wrap svg { display: block; overflow: visible; }

  /* ── Examples panel ──────────────────────────────────────── */
  .examples {
    border-radius: 0 0 8px 8px;
    padding: 16px 20px 18px;
    animation: slideDown .16s ease-out;
  }
  @keyframes slideDown {
    from { opacity: 0; transform: translateY(-6px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  .examples-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 14px;
  }
  .examples-title { font-size: 11px; font-weight: 700; letter-spacing: .04em; }

  .close-btn {
    background: none;
    font-family: var(--font);
    font-size: 9px;
    padding: 2px 9px;
    border-radius: 4px;
    cursor: pointer;
    letter-spacing: .06em;
  }

  .example-block { margin-bottom: 18px; }
  .example-block:last-child { margin-bottom: 0; }

  .example-head {
    display: flex;
    gap: 10px;
    align-items: baseline;
    margin-bottom: 8px;
  }
  .example-mnemonic { font-size: 12px; font-weight: 700; color: #e2e8f0; }
  .example-asm      { font-size: 10px; color: #2d3f55; }

  .byte-row {
    display: flex;
    gap: 2px;
    flex-wrap: wrap;
    align-items: flex-start;
  }

  .byte-card { display: flex; flex-direction: column; align-items: center; margin-right: 2px; margin-bottom: 2px; }

  .byte-box {
    background: #0c111f;
    border-radius: 6px;
    width: 68px;
    padding: 6px 0 22px;
    text-align: center;
    position: relative;
  }
  .byte-hex   { font-size: 17px; font-weight: 700; }
  .byte-field-label {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    border-radius: 0 0 5px 5px;
    padding: 2px 3px;
    font-size: 7px;
    font-weight: 700;
    letter-spacing: .04em;
    text-align: center;
  }
  .byte-note {
    margin-top: 4px;
    color: #384a5f;
    font-size: 7.8px;
    width: 68px;
    line-height: 1.35;
    padding-left: 1px;
  }

  .byte-count {
    font-size: 9px;
    padding: 3px 9px;
    border-radius: 12px;
    margin-top: 8px;
    margin-left: 6px;
  }

  /* ── Footer ──────────────────────────────────────────────── */
  #footer {
    padding: 8px 22px 16px;
    border-top: 1px solid #0a1020;
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    align-items: center;
  }
  .footer-note { color: #14243a; font-size: 8px; }

  .req-legend { margin-left: auto; display: flex; gap: 14px; }
  .req-item   { display: flex; align-items: center; gap: 6px; font-size: 8px; color: #2a3a50; }

  /* ── Tooltip ─────────────────────────────────────────────── */
  #tooltip {
    position: fixed;
    pointer-events: none;
    display: none;
    z-index: 1000;
    background: #09101e;
    border-radius: 8px;
    padding: 10px 11px 10px;
    max-width: 320px;
    box-shadow: 0 10px 30px #000;
    font-size: 9.5px;
    line-height: 1.55;
    white-space: pre-wrap;
    border: 1px solid #1a2a41;
  }
  #tooltip.pinned {
    pointer-events: auto;
    border-color: #2b4364;
  }
  #tooltip .tooltip-head{
    display:none;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin:-2px 0 8px 0;
    padding:0 0 8px 0;
    border-bottom:1px solid #13243a;
  }
  #tooltip.pinned .tooltip-head{ display:flex; }
  #tooltip .tooltip-badge{
    font-size:8px;
    letter-spacing:.12em;
    color:#9fb5d4;
    opacity:.95;
  }
  #tooltip .tooltip-close{
    cursor:pointer;
    border:1px solid #203750;
    background:transparent;
    color:#9fb5d4;
    border-radius:6px;
    width:22px;height:22px;
    line-height:18px;
    font-size:14px;
  }
  #tooltip .tooltip-close:hover{ filter:brightness(1.2); }
  #tooltip .tooltip-body{ color:inherit; }

  #footer .footer-note{
    margin: 10px 0 10px;
    font-size: 9px;
    letter-spacing: .06em;
    color: #9fb5d4;
    opacity: .9;
  }
  #footer details.footer-validate{
    margin-top: 12px;
    border: 1px solid #0d1526;
    background: #050915;
    border-radius: 10px;
    padding: 10px 12px;
  }
  #footer details.footer-validate summary{
    cursor: pointer;
    font-size: 9.5px;
    letter-spacing: .05em;
    color: #cfe0f7;
    list-style: none;
  }
  #footer details.footer-validate summary::-webkit-details-marker { display:none; }
  #footer pre.validate-code{
    margin-top: 10px;
    padding: 10px 12px;
    border-radius: 10px;
    background: #070c18;
    border: 1px solid #0f1b30;
    overflow: auto;
    font-size: 9px;
    line-height: 1.5;
    color: #dde3ec;
  }

  #footer .footer-note, #footer details.footer-validate{ flex: 1 1 100%; }
</style>
</head>
<body>
<div id="header">
<div>
<h1>x86-64 Encoding Atlas</h1>
<p>BYTE TRAJECTORY REFERENCE · HOVER FIELD FOR DETAILS · CLICK FIELD TO PIN · CLICK ROW FOR EXAMPLES · DASHED BORDER = OPTIONAL</p>
</div>
<div id="legend"></div>
</div>
<div id="diagram">
<div id="col-headers">
<div class="col-hdr">PREFIX / MARKER</div>
<div class="col-hdr">PAYLOAD / ESCAPE</div>
<div class="col-hdr">OPCODE</div>
<div class="col-hdr">ModRM</div>
<div class="col-hdr">SIB</div>
<div class="col-hdr">DISP</div>
<div class="col-hdr">IMM</div>
</div>
<div id="diagram-inner"></div>
</div>
<div id="footer"><div class="footer-note">Tooltip: hover to preview · click a field to pin · ESC or × to unpin</div>
<span class="footer-note">Max length: 15 bytes</span>
<span class="footer-note">REX / legacy prefixes forbidden with VEX · EVEX · XOP</span>
<span class="footer-note">XOP removed on AMD Zen and later (Bulldozer-era only)</span>
<span class="footer-note">EVEX MAP5/MAP6: used by many AVX-512 FP16 encodings (and AVX10.x FP16)</span>
<div class="req-legend">
<div class="req-item">
<svg height="16" width="36"><rect fill="#06090f" height="12" rx="3" stroke="#6b7a8d" stroke-width="2" width="34" x="1" y="2"></rect></svg>
      required
    </div>
<div class="req-item">
<svg height="16" width="36"><rect fill="#06090f" height="12" opacity="0.7" rx="3" stroke="#6b7a8d" stroke-dasharray="5 3" stroke-width="1.5" width="34" x="1" y="2"></rect></svg>
      optional
    </div>
</div>
<details class="footer-validate"><summary>Validation gate (recommended for maintaining byte-accurate examples)</summary><pre class="validate-code"># Minimal round-trip check idea (Linux/macOS)
# 1) Assemble the examples
# 2) objdump the bytes and compare against the presentation data

cat &gt; validate.s &lt;&lt;'EOF'
.intel_syntax noprefix
.text
.globl _start
_start:
  # add one line per example you want to validate
  vaddps xmm16, xmm17, XMMWORD PTR [rsi]
  vprotb xmm0, xmm1, xmm2
EOF

as --64 validate.s -o validate.o
objdump -d validate.o
</pre></details></div>
<div aria-hidden="true" id="tooltip" role="tooltip">
<div class="tooltip-head">
<span class="tooltip-badge">PINNED</span>
<button aria-label="Unpin tooltip" class="tooltip-close" type="button">×</button>
</div>
<div class="tooltip-body"></div>
</div>
<script>
// ─── Data ──────────────────────────────────────────────────────────────────
const COLS = {
  legpfx:  { cx: 268 },
  rex:     { cx: 354 },
  marker:  { cx: 300 },
  payload: { cx: 410 },
  esc:     { cx: 440 },

  opcode:  { cx: 545 },
  modrm:   { cx: 655 },
  sib:     { cx: 753 },
  disp:    { cx: 851 },
  imm:     { cx: 955 },
};
const SVG_W = 1040, ROW_H = 68, BOX_H = 38;

const GROUPS = [
  {
    id: "legacy", label: "LEGACY", color: "#7dd3fc",
    families: [
      {
        id: "prim", name: "Primary map",
        tag: "No escape — most common instructions",
        color: "#7dd3fc", bg: "#040c18",
        fields: [
          { col: "legpfx", w: 78, label: "Legacy Pfx", sub: "0–4 bytes", opt: true,
            tip: "Up to 4 prefixes in any order:\n• LOCK (F0)\n• REP/REPNE (F2/F3)\n• Segment override (26 2E 36 3E 64 65)\n• Operand-size (66)\n• Address-size (67)" },
          { col: "rex", w: 42, label: "REX", sub: "40h–4Fh", opt: true,
            tip: "REX.WRXB (one byte):\n• W – 64-bit operand size\n• R – extends ModRM.reg to 4 bits\n• X – extends SIB.index\n• B – extends ModRM.r/m or opcode-embedded reg" },
          { col: "opcode", w: 84, label: "Opcode", sub: "1 byte", opt: false,
            tip: "One byte from the primary map (00h–FFh).\nBits[2:0] may encode a register (e.g. PUSH rAX = 50h+rb)." },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: true,
            tip: "mod(2) · reg(3) · r/m(3)\nmod=11 → reg/reg; 00/01/10 → memory\nreg may be an opcode extension (/digit 0–7)." },
          { col: "sib", w: 72, label: "SIB", sub: "1 byte", opt: true,
            tip: "scale(2) · index(3) · base(3)\nRequired when mod≠11 and r/m=100b.\nAddress: base + index×(1<<scale) + disp" },
          { col: "disp", w: 78, label: "Disp", sub: "0/1/2/4B", opt: true,
            tip: "Memory displacement, sign-extended to address size." },
          { col: "imm", w: 82, label: "Imm", sub: "0/1/2/4/8B", opt: true,
            tip: "Immediate value, sign/zero-extended to operand size." },
        ],
        examples: [
          { mnemonic: "ADD rax, rcx", asm: "; 64-bit register add",
            bytes: [
              { hex: "48", field: "REX",    color: "#93c5fd", note: "REX.W=1 → 64-bit operand size" },
              { hex: "01", field: "Opcode", color: "#38bdf8", note: "ADD r/m, r" },
              { hex: "C8", field: "ModRM",  color: "#a78bfa", note: "mod=11 reg=rcx(1) r/m=rax(0)" },
            ]},
          { mnemonic: "PUSH rbx", asm: "; no REX needed",
            bytes: [
              { hex: "53", field: "Opcode", color: "#38bdf8", note: "PUSH r64, opcode = 50h+rb (rb=3 for rbx)" },
            ]},
          { mnemonic: "MOV [rsi+0x10], al", asm: "; byte store with disp8",
            bytes: [
              { hex: "88", field: "Opcode", color: "#38bdf8", note: "MOV r/m8, r8" },
              { hex: "46", field: "ModRM",  color: "#a78bfa", note: "mod=01 reg=al(0) r/m=rsi(6)" },
              { hex: "10", field: "Disp",   color: "#f472b6", note: "disp8 = +0x10" },
            ]},
        ],
      },

      {
        id: "addr", name: "Addressing traps", 
        tag: "ModRM/SIB corner cases (rsp/rbp/r13/rip/addr32)",
        color: "#7dd3fc", bg: "#040c18",
        fields: [
          { col: "legpfx", w: 78, label: "Legacy Pfx", sub: "0–4 bytes", opt: true,
            tip: "Includes address-size override (67h) and operand-size override (66h).\nThese are still legal with legacy encodings and can change decoding rules." },
          { col: "rex", w: 42, label: "REX", sub: "40h–4Fh", opt: true,
            tip: "REX.WRXB (one byte).\nTraps here: B extends base (ModRM.r/m or SIB.base), X extends SIB.index." },
          { col: "opcode", w: 84, label: "Opcode", sub: "1 byte", opt: false,
            tip: "Example opcodes here are MOV (8Bh/89h). Structure is the point — not the mnemonic." },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: true,
            tip: "mod(2) · reg(3) · r/m(3)\nKey traps:\n• mod≠11 & r/m=100b → SIB is present\n• mod=00 & r/m=101b → disp32 (RIP-relative in 64-bit mode)\n• base=RBP/R13 cannot use mod=00 without a disp" },
          { col: "sib", w: 72, label: "SIB", sub: "1 byte", opt: true,
            tip: "scale(2) · index(3) · base(3)\nKey traps:\n• base=100b selects RSP/R12 (and often forces SIB)\n• index=100b means “no index” (not RSP)\n• base=101b with mod=00 implies disp32 (no base)" },
          { col: "disp", w: 78, label: "Disp", sub: "0/1/2/4B", opt: true,
            tip: "Many addressing traps resolve by emitting disp8=00 (a real byte) to avoid the mod=00 special cases." },
          { col: "imm", w: 82, label: "Imm", sub: "—", opt: true,
            tip: "Not used in these examples." },
        ],
        examples: [
          { mnemonic: "MOV [rsp+0x20], rax", asm: "; RSP base forces SIB",
            bytes: [
              { hex: "48", field: "REX",    color: "#93c5fd", note: "W=1 → r/m64, r64" },
              { hex: "89", field: "Opcode", color: "#38bdf8", note: "MOV r/m64, r64" },
              { hex: "44", field: "ModRM",  color: "#a78bfa", note: "mod=01 reg=rax r/m=100 → SIB follows" },
              { hex: "24", field: "SIB",    color: "#c4b5fd", note: "scale=0 index=100(no index) base=100(rsp)" },
              { hex: "20", field: "Disp8",  color: "#fbbf24", note: "+0x20" },
            ]},
          { mnemonic: "MOV eax, [rsp]", asm: "; [rsp] also forces SIB",
            bytes: [
              { hex: "8B", field: "Opcode", color: "#38bdf8", note: "MOV r32, r/m32" },
              { hex: "04", field: "ModRM",  color: "#a78bfa", note: "mod=00 reg=eax r/m=100 → SIB follows" },
              { hex: "24", field: "SIB",    color: "#c4b5fd", note: "index=100(no index) base=100(rsp)" },
            ]},
          { mnemonic: "MOV eax, [rbp]", asm: "; RBP cannot use mod=00 → disp8=0",
            bytes: [
              { hex: "8B", field: "Opcode", color: "#38bdf8", note: "MOV r32, r/m32" },
              { hex: "45", field: "ModRM",  color: "#a78bfa", note: "mod=01 reg=eax r/m=101(rbp)" },
              { hex: "00", field: "Disp8",  color: "#fbbf24", note: "disp8=0 (required)" },
            ]},
          { mnemonic: "MOV eax, [r13]", asm: "; same trap as RBP (requires disp)",
            bytes: [
              { hex: "41", field: "REX",    color: "#93c5fd", note: "B=1 → base=r13" },
              { hex: "8B", field: "Opcode", color: "#38bdf8", note: "MOV r32, r/m32" },
              { hex: "45", field: "ModRM",  color: "#a78bfa", note: "mod=01 reg=eax r/m=101(+B → r13)" },
              { hex: "00", field: "Disp8",  color: "#fbbf24", note: "disp8=0 (required)" },
            ]},
          { mnemonic: "MOV eax, [rip+0x11223344]", asm: "; mod=00 r/m=101 → disp32",
            bytes: [
              { hex: "8B", field: "Opcode", color: "#38bdf8", note: "MOV r32, r/m32" },
              { hex: "05", field: "ModRM",  color: "#a78bfa", note: "mod=00 reg=eax r/m=101 → disp32 (RIP-rel)" },
              { hex: "44", field: "Disp32", color: "#fbbf24", note: "0x11223344 (low)" },
              { hex: "33", field: "Disp32", color: "#fbbf24", note: "" },
              { hex: "22", field: "Disp32", color: "#fbbf24", note: "" },
              { hex: "11", field: "Disp32", color: "#fbbf24", note: "" },
            ]},
          { mnemonic: "MOV eax, [eax] (addr32)", asm: "; 67h overrides address size in 64-bit mode",
            bytes: [
              { hex: "67", field: "Pfx",    color: "#7dd3fc", note: "Address-size override (addr32)" },
              { hex: "8B", field: "Opcode", color: "#38bdf8", note: "MOV r32, r/m32" },
              { hex: "00", field: "ModRM",  color: "#a78bfa", note: "mod=00 reg=eax r/m=eax" },
            ]},
        ],
      },
      {
        id: "esc2", name: "0F — Two-byte map",
        tag: "SSE integer/FP, system, VMX…",
        color: "#38bdf8", bg: "#030e15",
        fields: [
          { col: "legpfx", w: 78, label: "Legacy Pfx", sub: "0–4 bytes", opt: true,
            tip: "66h → SSE2 (66 0F)\nF3h → SSE scalar-single\nF2h → SSE scalar-double" },
          { col: "rex", w: 42, label: "REX", sub: "40h–4Fh", opt: true,
            tip: "Same REX.WRXB semantics." },
          { col: "esc", w: 80, label: "0Fh", sub: "escape", opt: false,
            tip: "Escape byte 0Fh selects the two-byte opcode map.\nThe mandatory prefix (if any) determines the variant:\n• (none) 0F → original\n• 66 0F   → SSE2\n• F3 0F   → SSEf3\n• F2 0F   → SSEf2" },
          { col: "opcode", w: 84, label: "Opcode", sub: "map 0F", opt: false,
            tip: "Second opcode byte (00h–FFh).\n28h=MOVAPS, 57h=XORPS, AFh=IMUL r,r/m, AEh=SFENCE/LFENCE" },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: true, tip: "ModRM where required." },
          { col: "sib",   w: 72, label: "SIB",   sub: "1 byte", opt: true, tip: "SIB for memory operand." },
          { col: "disp",  w: 78, label: "Disp",  sub: "0/1/2/4B", opt: true, tip: "Displacement." },
          { col: "imm",   w: 82, label: "Imm",   sub: "0/1B", opt: true, tip: "Imm8 for select instructions (e.g. PSRLW imm8)." },
        ],
        examples: [
          { mnemonic: "MOVAPS xmm0, xmm1", asm: "; move aligned packed single",
            bytes: [
              { hex: "0F", field: "Escape", color: "#22d3ee", note: "0F escape" },
              { hex: "28", field: "Opcode", color: "#38bdf8", note: "MOVAPS xmm, xmm/m128" },
              { hex: "C1", field: "ModRM",  color: "#a78bfa", note: "mod=11 reg=xmm0(0) r/m=xmm1(1)" },
            ]},
          { mnemonic: "ADDSD xmm2, xmm3", asm: "; F2 prefix → scalar double",
            bytes: [
              { hex: "F2", field: "Pfx",    color: "#7dd3fc", note: "F2h mandatory prefix" },
              { hex: "0F", field: "Escape", color: "#22d3ee", note: "0F escape" },
              { hex: "58", field: "Opcode", color: "#38bdf8", note: "ADDSD" },
              { hex: "D3", field: "ModRM",  color: "#a78bfa", note: "mod=11 reg=xmm2 r/m=xmm3" },
            ]},
          { mnemonic: "IMUL rax, rcx", asm: "; signed multiply",
            bytes: [
              { hex: "48", field: "REX",    color: "#93c5fd", note: "REX.W=1" },
              { hex: "0F", field: "Escape", color: "#22d3ee", note: "0F escape" },
              { hex: "AF", field: "Opcode", color: "#38bdf8", note: "IMUL r64, r/m64" },
              { hex: "C1", field: "ModRM",  color: "#a78bfa", note: "mod=11 reg=rax r/m=rcx" },
            ]},
        ],
      },
      {
        id: "map38", name: "0F 38 — Three-byte map",
        tag: "SSSE3, SSE4.1, SSE4.2, AES-NI, SHA…",
        color: "#22d3ee", bg: "#021212",
        fields: [
          { col: "legpfx", w: 78, label: "Legacy Pfx", sub: "0–4 bytes", opt: true,
            tip: "66h selects the most common variants.\nF2 0F 38: CRC32, ADCX.\n(none) 0F 38: MMX PSHUFB, PMADDUBSW." },
          { col: "rex", w: 42, label: "REX", sub: "40h–4Fh", opt: true, tip: "REX.WRXB." },
          { col: "esc", w: 80, label: "0Fh · 38h", sub: "2 escapes", opt: false,
            tip: "0F 38h → three-byte opcode map.\nSSSE3, SSE4.1, SSE4.2, AES-NI, SHA extensions." },
          { col: "opcode", w: 84, label: "Opcode", sub: "map 0F38", opt: false, tip: "Third opcode byte." },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: false, tip: "ModRM always present in this map." },
          { col: "sib",   w: 72, label: "SIB",   sub: "1 byte", opt: true, tip: "SIB for memory." },
          { col: "disp",  w: 78, label: "Disp",  sub: "0/1/2/4B", opt: true, tip: "Displacement." },
        ],
        examples: [
          { mnemonic: "PSHUFB xmm0, xmm1", asm: "; SSSE3 per-byte shuffle",
            bytes: [
              { hex: "66", field: "Pfx",    color: "#7dd3fc", note: "mandatory 66h" },
              { hex: "0F", field: "Escape", color: "#22d3ee", note: "first escape" },
              { hex: "38", field: "Escape", color: "#22d3ee", note: "second escape" },
              { hex: "00", field: "Opcode", color: "#38bdf8", note: "PSHUFB xmm, xmm/m128" },
              { hex: "C1", field: "ModRM",  color: "#a78bfa", note: "mod=11 dst=xmm0 src=xmm1" },
            ]},
          { mnemonic: "AESENC xmm0, xmm1", asm: "; AES-NI one round",
            bytes: [
              { hex: "66", field: "Pfx",    color: "#7dd3fc", note: "mandatory 66h" },
              { hex: "0F", field: "Escape", color: "#22d3ee", note: "first escape" },
              { hex: "38", field: "Escape", color: "#22d3ee", note: "second escape" },
              { hex: "DC", field: "Opcode", color: "#38bdf8", note: "AESENC xmm, xmm/m128" },
              { hex: "C1", field: "ModRM",  color: "#a78bfa", note: "mod=11 dst=xmm0 src=xmm1" },
            ]},
        ],
      },
      {
        id: "map3a", name: "0F 3A — Three-byte map",
        tag: "All instructions carry a mandatory imm8 control byte",
        color: "#06b6d4", bg: "#021014",
        fields: [
          { col: "legpfx", w: 78, label: "Legacy Pfx", sub: "0–4 bytes", opt: true,
            tip: "66h nearly always required.\nROUNDSS/D/PS/PD, PBLENDW, PCMPISTRM, AESKEYGENASSIST." },
          { col: "rex", w: 42, label: "REX", sub: "40h–4Fh", opt: true, tip: "REX prefix." },
          { col: "esc", w: 80, label: "0Fh · 3Ah", sub: "2 escapes", opt: false,
            tip: "0F 3Ah → three-byte map.\nEvery instruction ends with an imm8 control byte:\nrounding mode, blend mask, comparison predicate, lane selector…" },
          { col: "opcode", w: 84, label: "Opcode", sub: "map 0F3A", opt: false, tip: "Third opcode byte." },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: false, tip: "ModRM always present." },
          { col: "sib",   w: 72, label: "SIB",   sub: "1 byte", opt: true, tip: "SIB when needed." },
          { col: "disp",  w: 78, label: "Disp",  sub: "0/1/2/4B", opt: true, tip: "Displacement." },
          { col: "imm",   w: 82, label: "Imm8",  sub: "always present", opt: false,
            tip: "Imm8 always required — a control byte, not data:\n• ROUNDSS: rounding mode + SAE flag\n• PCMPISTRI: comparison mode, output select\n• PBLENDW: blend mask for 8 word lanes\n• PALIGNR: byte shift amount" },
        ],
        examples: [
          { mnemonic: "ROUNDSS xmm0, xmm1, 0", asm: "; round to nearest",
            bytes: [
              { hex: "66", field: "Pfx",    color: "#7dd3fc", note: "mandatory 66h" },
              { hex: "0F", field: "Escape", color: "#22d3ee", note: "first escape" },
              { hex: "3A", field: "Escape", color: "#22d3ee", note: "second escape" },
              { hex: "0A", field: "Opcode", color: "#38bdf8", note: "ROUNDSS" },
              { hex: "C1", field: "ModRM",  color: "#a78bfa", note: "mod=11 dst=xmm0 src=xmm1" },
              { hex: "00", field: "Imm8",   color: "#f59e0b", note: "rounding mode=00 (nearest), SAE=0" },
            ]},
          { mnemonic: "PBLENDW xmm0, xmm1, 0xAA", asm: "; blend even words",
            bytes: [
              { hex: "66", field: "Pfx",    color: "#7dd3fc", note: "mandatory 66h" },
              { hex: "0F", field: "Escape", color: "#22d3ee", note: "escape" },
              { hex: "3A", field: "Escape", color: "#22d3ee", note: "escape" },
              { hex: "0E", field: "Opcode", color: "#38bdf8", note: "PBLENDW" },
              { hex: "C1", field: "ModRM",  color: "#a78bfa", note: "mod=11 dst=xmm0 src=xmm1" },
              { hex: "AA", field: "Imm8",   color: "#f59e0b", note: "blend mask 10101010b → even lanes" },
            ]},
        ],
      },
      {
        id: "tdnow", name: "3DNow! (0F 0F)",
        tag: "AMD only — actual opcode byte lives after ModRM/SIB/Disp",
        color: "#fb923c", bg: "#120600",
        fields: [
          { col: "legpfx", w: 78, label: "Legacy Pfx", sub: "0–4 bytes", opt: true, tip: "Legacy prefixes rarely used in 3DNow!." },
          { col: "rex", w: 42, label: "REX", sub: "40h–4Fh", opt: true, tip: "REX in 64-bit mode." },
          { col: "esc", w: 80, label: "0Fh · 0Fh", sub: "2 escapes", opt: false,
            tip: "Unusual design: two 0F escape bytes.\nThe real opcode is the LAST byte — after all operand fields.\nThis minimised decoder changes for the K6 era.\nAMD-only; deprecated on Zen 4+." },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: false,
            tip: "Source = MMX reg or 64-bit memory.\nDestination always in ModRM.reg." },
          { col: "sib",   w: 72, label: "SIB",   sub: "1 byte", opt: true, tip: "SIB for memory source." },
          { col: "disp",  w: 78, label: "Disp",  sub: "0/1/2/4B", opt: true, tip: "Displacement for memory source." },
          { col: "imm",   w: 82, label: "Opcode!", sub: "in imm8 slot", opt: false,
            tip: "The actual opcode occupies the imm8 slot!\n• 9Eh = PFADD\n• AEh = PFSUBR\n• B4h = PFMUL\n• 1Dh = PF2ID, 0Dh = PI2FD\nAMD-only. Deprecated (Zen 4+)." },
        ],
        examples: [
          { mnemonic: "PFADD mm0, mm1", asm: "; packed float add",
            bytes: [
              { hex: "0F", field: "Escape",  color: "#22d3ee", note: "first escape" },
              { hex: "0F", field: "Escape",  color: "#22d3ee", note: "second escape → 3DNow!" },
              { hex: "C1", field: "ModRM",   color: "#a78bfa", note: "mod=11 dst=mm0 src=mm1" },
              { hex: "9E", field: "Opcode!", color: "#fb923c", note: "PFADD — opcode is LAST, after operands" },
            ]},
          { mnemonic: "PFMUL mm2, [rsi]", asm: "; multiply from memory",
            bytes: [
              { hex: "0F", field: "Escape",  color: "#22d3ee", note: "first escape" },
              { hex: "0F", field: "Escape",  color: "#22d3ee", note: "second escape" },
              { hex: "16", field: "ModRM",   color: "#a78bfa", note: "mod=00 dst=mm2 r/m=rsi(6)" },
              { hex: "B4", field: "Opcode!", color: "#fb923c", note: "PFMUL — after the ModRM" },
            ]},
        ],
      },
    ],
  },
  {
    id: "vex", label: "VEX", color: "#a78bfa",
    families: [
      {
        id: "vex2", name: "VEX 2-byte (C5h)",
        tag: "Map 1 only · 128/256-bit · REX and legacy prefixes forbidden",
        color: "#a78bfa", bg: "#0d0620",
        fields: [
          { col: "marker", w: 42, label: "C5h", sub: "VEX 2B marker", opt: false,
            tip: "VEX 2-byte prefix marker C5h.\nAll legacy prefixes and REX are FORBIDDEN.\nThe payload encodes what REX/mandatory-prefix would have been.\nIn 32-bit mode 0xC5 can also start LDS; VEX2 is recognized when the following byte matches the VEX2 payload pattern (bits[7:6]=11)." },
          { col: "payload", w: 126, label: "R̄ · v̄v̄v̄v̄ · L · pp", sub: "1 payload byte", opt: false,
            tip: "One payload byte, 8 bits:\n• [7] R̄   inverted REX.R\n• [6:3] v̄v̄v̄v̄  inverted vvvv — 2nd source register\n• [2] L   0=128b XMM, 1=256b YMM\n• [1:0] pp  implied mandatory prefix:\n   00=none  01=66h  10=F3h  11=F2h\n\nMap 1 only. No REX.W / X / B → use 3-byte for those." },
          { col: "opcode", w: 84, label: "Opcode", sub: "map 1", opt: false,
            tip: "Opcode from map 1 (equivalent to 0F xx).\nDestination in ModRM.reg, extended by R̄." },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: true, tip: "ModRM." },
          { col: "sib",   w: 72, label: "SIB",   sub: "1 byte", opt: true, tip: "SIB for memory." },
          { col: "disp",  w: 78, label: "Disp",  sub: "0/1/2/4B", opt: true, tip: "Displacement." },
          { col: "imm",   w: 82, label: "Imm",   sub: "0/1B", opt: true,
            tip: "Optional imm8.\nFor 4-operand (is4) forms: bits[7:4] encode a 4th register." },
        ],
        examples: [
          { mnemonic: "VMOVAPS xmm1, xmm2", asm: "; no REX, no 0F, no 66 needed",
            bytes: [
              { hex: "C5", field: "C5h",    color: "#a78bfa", note: "VEX 2-byte marker" },
              { hex: "F8", field: "Payload",color: "#c084fc", note: "R̄=1 vvvv=1111(unused) L=0(XMM) pp=00" },
              { hex: "28", field: "Opcode", color: "#38bdf8", note: "VMOVAPS (map 1 = 0F 28)" },
              { hex: "CA", field: "ModRM",  color: "#a78bfa", note: "mod=11 reg=xmm1 r/m=xmm2" },
            ]},
          { mnemonic: "VADDPS ymm0, ymm1, ymm2", asm: "; L=1 selects 256-bit YMM",
            bytes: [
              { hex: "C5", field: "C5h",    color: "#a78bfa", note: "VEX 2-byte marker" },
              { hex: "F4", field: "Payload",color: "#c084fc", note: "R̄=1 vvvv=1110(ymm1) L=1(YMM) pp=00" },
              { hex: "58", field: "Opcode", color: "#38bdf8", note: "VADDPS" },
              { hex: "C2", field: "ModRM",  color: "#a78bfa", note: "mod=11 reg=ymm0 r/m=ymm2" },
            ]},
          { mnemonic: "VADDSD xmm0, xmm1, xmm2", asm: "; F2 via pp=11 — no F2 byte emitted",
            bytes: [
              { hex: "C5", field: "C5h",    color: "#a78bfa", note: "VEX 2-byte marker" },
              { hex: "F3", field: "Payload",color: "#c084fc", note: "R̄=1 vvvv=1110(xmm1) L=0 pp=11(F2h)" },
              { hex: "58", field: "Opcode", color: "#38bdf8", note: "VADDSD" },
              { hex: "C2", field: "ModRM",  color: "#a78bfa", note: "mod=11 reg=xmm0 r/m=xmm2" },
            ]},
        ],
      },
      {
        id: "vex3", name: "VEX 3-byte (C4h)",
        tag: "Maps 1/2/3 · full R/X/B extension · REX.W · no legacy prefixes",
        color: "#c084fc", bg: "#100826",
        fields: [
          { col: "marker", w: 42, label: "C4h", sub: "VEX 3B marker", opt: false,
            tip: "VEX 3-byte marker C4h.\nForbids legacy prefixes and REX.\nRequired when: maps 2 or 3 needed, REX.W needed, or REX.X/B extension needed." },
          { col: "payload", w: 126, label: "R̄X̄B̄·mmm  ·  W·v̄v̄v̄v̄·L·pp", sub: "2 payload bytes", opt: false,
            tip: "Byte 1: [7]R̄ [6]X̄ [5]B̄ [4:0]map\n• R̄ – inverted REX.R\n• X̄ – inverted REX.X\n• B̄ – inverted REX.B\n• map: 001=map1  010=map2  011=map3\n\nByte 2: [7]W [6:3]v̄v̄v̄v̄ [2]L [1:0]pp\n• W – REX.W / element type\n• vvvv – inverted NDS register\n• L – vector length\n• pp – implied mandatory prefix" },
          { col: "opcode", w: 84, label: "Opcode", sub: "map 1/2/3", opt: false, tip: "Opcode from the selected map." },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: true, tip: "All register fields fully extended." },
          { col: "sib",   w: 72, label: "SIB",   sub: "1 byte", opt: true, tip: "SIB for memory." },
          { col: "disp",  w: 78, label: "Disp",  sub: "0/1/2/4B", opt: true, tip: "Displacement." },
          { col: "imm",   w: 82, label: "Imm",   sub: "0/1B", opt: true, tip: "Optional imm8. Bits[7:4] may encode a 4th register (is4)." },
        ],
        examples: [
          { mnemonic: "VFMADD213PS ymm0, ymm1, ymm2", asm: "; map 2 (0F38) instruction",
            bytes: [
              { hex: "C4", field: "C4h",     color: "#c084fc", note: "VEX 3-byte marker" },
              { hex: "E2", field: "Payload1",color: "#a78bfa", note: "R̄=1 X̄=1 B̄=1 map=010 (0F38)" },
              { hex: "75", field: "Payload2",color: "#a78bfa", note: "W=0 vvvv=1110(ymm1) L=1(YMM) pp=01(66h)" },
              { hex: "A8", field: "Opcode",  color: "#38bdf8", note: "VFMADD213PS" },
              { hex: "C2", field: "ModRM",   color: "#a78bfa", note: "mod=11 reg=ymm0 r/m=ymm2" },
            ]},
          { mnemonic: "VPERMILPS ymm0, ymm1, imm8", asm: "; map 3 (0F3A), shuffle control",
            bytes: [
              { hex: "C4", field: "C4h",     color: "#c084fc", note: "VEX 3-byte marker" },
              { hex: "E3", field: "Payload1",color: "#a78bfa", note: "R̄=1 X̄=1 B̄=1 map=011 (0F3A)" },
              { hex: "7D", field: "Payload2",color: "#a78bfa", note: "W=0 vvvv=1111 L=1(YMM) pp=01(66h)" },
              { hex: "04", field: "Opcode",  color: "#38bdf8", note: "VPERMILPS" },
              { hex: "C1", field: "ModRM",   color: "#a78bfa", note: "mod=11 reg=ymm0 r/m=ymm1" },
              { hex: "E4", field: "Imm8",    color: "#f59e0b", note: "shuffle control byte" },
            ]},
        ],
      },
    ],
  },
  {
    id: "evex", label: "EVEX", color: "#f472b6",
    families: [
      {
        id: "evex", name: "EVEX (62h)",
        tag: "AVX-512 / AVX10 · ZMM/YMM/XMM · opmask k0–k7 · broadcast · embedded rounding",
        color: "#f472b6", bg: "#180410",
        fields: [
          { col: "marker", w: 42, label: "62h", sub: "EVEX marker", opt: false,
            tip: "EVEX marker 62h.\nIn 64-bit mode BOUND is removed, freeing 62h.\nREX and VEX strictly forbidden.\nTotal instruction length ≤ 15 bytes." },
          { col: "payload", w: 126, label: "P0 · P1 · P2", sub: "3 payload bytes", opt: false,
            tip: "P0: R̄ X̄ B̄ R̄' · 00 · mm\n• R̄X̄B̄ – inverted REX.RXB\n• R̄' – extends reg to 5 bits (32 regs)\n• mm: 01=map1, 02=map2, 03=map3, 05=MAP5, 06=MAP6\n\nP1: W · v̄v̄v̄v̄ · 1 · pp\n• W – operand size / element type\n• vvvv – inverted NDS register\n• pp – implied mandatory prefix\n\nP2: z · L' · L · b · V̄' · aaa\n• z – 0=merge masking, 1=zero masking\n• L'L – 00=XMM, 01=YMM, 10=ZMM\n• b – memory: broadcast; register: embedded rounding/SAE\n• V̄' – extends vvvv to 5 bits (32 NDS regs)\n• aaa – opmask: k0=no mask, k1–k7=apply mask" },
          { col: "opcode", w: 84, label: "Opcode", sub: "maps 1–6", opt: false,
            tip: "Opcode from selected map.\nMAP5/MAP6: AVX-512 FP16 (AVX10):\nVMOVSH, VADDPH, VCVTPH2PS…" },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: false,
            tip: "Always present.\nreg extended to 5 bits (R + R') → 32 ZMM registers." },
          { col: "sib", w: 72, label: "SIB/VSIB", sub: "1 byte", opt: true,
            tip: "SIB: standard base-index-scale.\nVSIB: index is XMM/YMM/ZMM — used by gather/scatter:\n  VGATHERDPS, VPGATHERDD, VSCATTERQPD…" },
          { col: "disp", w: 78, label: "Disp*N", sub: "0/1*/4B", opt: true,
            tip: "Compressed disp8*N:\n1-byte disp8 scaled by tuple size N.\nRange: [−128N, 127N] — compact for common strides.\n4-byte full displacement also available." },
          { col: "imm", w: 82, label: "Imm8", sub: "0/1B", opt: true,
            tip: "Optional imm8 for rounding, permute control,\nshift count, comparison predicate." },
        ],
        examples: [
          { mnemonic: "VADDPS zmm0{k1}{z}, zmm1, zmm2", asm: "; 512-bit, masked, zeroing",
            bytes: [
              { hex: "62", field: "62h", color: "#f472b6", note: "EVEX marker" },
              { hex: "F1", field: "P0",  color: "#fb7185", note: "R̄=1 X̄=1 B̄=1 R̄'=1 mmm=001" },
              { hex: "74", field: "P1",  color: "#fb7185", note: "W=0 vvvv=1110(zmm1) pp=00" },
              { hex: "C9", field: "P2",  color: "#fb7185", note: "z=1(zero) L'L=10(ZMM) b=0 V'=1 aaa=001(k1)" },
              { hex: "58", field: "Opcode", color: "#38bdf8", note: "VADDPS" },
              { hex: "C2", field: "ModRM",  color: "#a78bfa", note: "mod=11 reg=zmm0 r/m=zmm2" },
            ]},
          { mnemonic: "VADDPS xmm16, xmm17, [rsi]", asm: "; EVEX extends to 32 SIMD regs",
            bytes: [
              { hex: "62", field: "62h", color: "#f472b6", note: "EVEX marker" },
              { hex: "E1", field: "P0",  color: "#fb7185", note: "mmm=001(0F map) · R̄X̄B̄=111 · R̄\'=0 (reg≥16)" },
              { hex: "74", field: "P1",  color: "#fb7185", note: "W=0 · vvvv→xmm17 · pp=00" },
              { hex: "00", field: "P2",  color: "#fb7185", note: "z=0 · L\'L=00(XMM) · b=0 · V\' (vvvv[4]) · aaa=000" },
              { hex: "58", field: "Opcode", color: "#38bdf8", note: "VADDPS" },
              { hex: "06", field: "ModRM",  color: "#a78bfa", note: "mod=00 reg=xmm16 r/m=[rsi]" },
            ]},
          { mnemonic: "VADDPS zmm0, zmm1, zmm2, {rn-sae}", asm: "; embedded rounding (b=1 on reg src)",
            bytes: [
              { hex: "62", field: "62h", color: "#f472b6", note: "EVEX marker" },
              { hex: "F1", field: "P0",  color: "#fb7185", note: "R̄X̄B̄R̄'=1111 mmm=001" },
              { hex: "74", field: "P1",  color: "#fb7185", note: "W=0 vvvv→zmm1 pp=00" },
              { hex: "18", field: "P2",  color: "#fb7185", note: "z=0 L'L=10(ZMM) b=1(rn-sae) aaa=0" },
              { hex: "58", field: "Opcode", color: "#38bdf8", note: "VADDPS" },
              { hex: "C2", field: "ModRM",  color: "#a78bfa", note: "mod=11 reg=zmm0 r/m=zmm2" },
            ]},
        ],
      },
    ],
  },
  {
    id: "xop", label: "XOP", color: "#fdba74",
    families: [
      {
        id: "xop", name: "XOP (8Fh)",
        tag: "AMD only — maps 8/9/A — no Intel support — deprecated Zen 4+",
        color: "#fdba74", bg: "#130700",
        fields: [
          { col: "marker", w: 42, label: "8Fh", sub: "XOP marker", opt: false,
            tip: "XOP marker 8Fh. AMD-specific; no Intel support.\nConflicts with POP in 32-bit mode — disambiguated by ModRM.reg ≠ 0.\nDeprecated: removed in AMD Zen 4 (2022)." },
          { col: "payload", w: 126, label: "R̄X̄B̄·mmm  ·  W·v̄v̄v̄v̄·L·pp", sub: "2 payload bytes (same layout as VEX 3B)", opt: false,
            tip: "Identical layout to VEX 3-byte:\nByte 1: R̄X̄B̄ + map_select\n• map 01000 (8) – integer: VPMACSDD, VPCMOV, VPPERM…\n• map 01001 (9) – shifts/rotates: VPROTB, VPSHAB…\n• map 01010 (A) – bit ops: BEXTR, BLCFILL, BLSR…\nMap values < 8 invalid in XOP (decode as VEX).\n\nByte 2: W.vvvv.L.pp — same meaning as VEX." },
          { col: "opcode", w: 84, label: "Opcode", sub: "map 8/9/A", opt: false,
            tip: "Opcode from XOP map 8, 9, or A." },
          { col: "modrm", w: 78, label: "ModRM", sub: "1 byte", opt: true, tip: "ModRM." },
          { col: "sib",   w: 72, label: "SIB",   sub: "1 byte", opt: true, tip: "SIB for memory." },
          { col: "disp",  w: 78, label: "Disp",  sub: "0/1/2/4B", opt: true, tip: "Displacement." },
          { col: "imm",   w: 82, label: "Imm",   sub: "0/1B", opt: true,
            tip: "Optional imm8. Bits[7:4] may encode a 4th register (is4)." },
        ],
        examples: [
          { mnemonic: "VPROTB xmm0, xmm1, xmm2", asm: "; XOP (Bulldozer-era AMD), 3-operand form",
            bytes: [
              { hex: "8F", field: "8Fh",     color: "#fb7185", note: "XOP marker" },
              { hex: "E9", field: "P1",      color: "#fb7185", note: "R̄X̄B̄ + mmmmm=01001 (map9)" },
              { hex: "68", field: "P2",      color: "#fb7185", note: "W=0 vvvv→xmm1 L=0 pp=00" },
              { hex: "90", field: "Opcode",  color: "#38bdf8", note: "VPROTB" },
              { hex: "C1", field: "ModRM",   color: "#a78bfa", note: "mod=11 reg=xmm0 r/m=xmm2" },
            ]},
          { mnemonic: "VPCMOV xmm0, xmm1, xmm2, xmm3", asm: "; XOP is4: imm8[7:4] selects 4th reg",
            bytes: [
              { hex: "8F", field: "8Fh",     color: "#fb7185", note: "XOP marker" },
              { hex: "E8", field: "P1",      color: "#fb7185", note: "R̄X̄B̄ + mmmmm=01000 (map8)" },
              { hex: "70", field: "P2",      color: "#fb7185", note: "W=0 vvvv→xmm1 L=0 pp=00" },
              { hex: "A2", field: "Opcode",  color: "#38bdf8", note: "VPCMOV (is4)" },
              { hex: "C2", field: "ModRM",   color: "#a78bfa", note: "mod=11 reg=xmm0 r/m=xmm2" },
              { hex: "30", field: "imm8",    color: "#fbbf24", note: "imm[7:4]=3 → xmm3" },
            ]},
        ],
      },
    ],
  },
];

// ─── Tooltip (hover + pin) ─────────────────────────────────────────────────
const tooltip = document.getElementById('tooltip');
const tooltipBody = tooltip.querySelector('.tooltip-body');
const tooltipClose = tooltip.querySelector('.tooltip-close');

let tipPinned = false;
let pinnedText = '';
let pinnedColor = '#dde3ec';

function setTip(text, color) {
  pinnedColor = color;
  tooltip.style.color = color;
  tooltip.style.borderColor = color + '66';
  tooltipBody.textContent = text;
  tooltip.setAttribute('aria-hidden', 'false');
}

function showTip(e, text, color) {
  if (tipPinned) return;
  tooltip.classList.remove('pinned');
  tooltip.style.display = 'block';
  setTip(text, color);
  moveTip(e, true);
}

function moveTip(e, force=false) {
  if (tipPinned && !force) return;
  const pad = 14;
  const tw = tooltip.offsetWidth;
  const th = tooltip.offsetHeight;
  let x = e.clientX + pad;
  let y = e.clientY - th / 2;
  if (x + tw > window.innerWidth - 8) x = e.clientX - tw - pad;
  if (y < 4) y = 4;
  if (y + th > window.innerHeight - 4) y = window.innerHeight - th - 4;
  tooltip.style.left = x + 'px';
  tooltip.style.top  = y + 'px';
}

function hideTip() {
  if (tipPinned) return;
  tooltip.style.display = 'none';
  tooltip.setAttribute('aria-hidden', 'true');
}

function pinTip(e, text, color) {
  tipPinned = true;
  pinnedText = text;
  tooltip.classList.add('pinned');
  tooltip.style.display = 'block';
  setTip(text, color);
  moveTip(e, true);
}

function unpinTip() {
  tipPinned = false;
  pinnedText = '';
  tooltip.classList.remove('pinned');
  tooltip.style.display = 'none';
  tooltip.setAttribute('aria-hidden', 'true');
}

function togglePin(e, text, color) {
  if (tipPinned && pinnedText === text) { unpinTip(); return; }
  pinTip(e, text, color);
}

tooltipClose.addEventListener('click', (e) => { e.stopPropagation(); unpinTip(); });
document.addEventListener('keydown', (e) => { if (e.key === 'Escape') unpinTip(); });
document.addEventListener('click', (e) => {
  if (!tipPinned) return;
  if (tooltip.contains(e.target)) return;
  unpinTip();
});

// ─── SVG row builder ───────────────────────────────────────────────────────
function buildRowSVG(family) {
  const ns = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(ns, 'svg');
  svg.setAttribute('viewBox', `0 0 ${SVG_W} ${ROW_H}`);
  svg.setAttribute('width', '100%');
  svg.style.display = 'block';
  svg.style.overflow = 'visible';

  const mk = (tag, attrs) => {
    const el = document.createElementNS(ns, tag);
    for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
    return el;
  };

  // Column guide lines
  for (const cx of [520, 630, 728, 826, 930]) {
    svg.appendChild(mk('line', { x1: cx-46, y1: 0, x2: cx-46, y2: ROW_H,
      stroke: '#0d1525', 'stroke-width': 1 }));
  }

  // Row tint
  svg.appendChild(mk('rect', { x: 8, y: 2, width: SVG_W-16, height: ROW_H-4,
    rx: 6, fill: family.bg }));

  const midY = ROW_H / 2, boxY = (ROW_H - BOX_H) / 2;
  const sorted = [...family.fields].sort((a,b) => COLS[a.col].cx - COLS[b.col].cx);
  const left  = f => COLS[f.col].cx - f.w / 2;
  const right = f => COLS[f.col].cx + f.w / 2;

  // Entry arrow
  svg.appendChild(mk('line', { x1: 10, y1: midY, x2: left(sorted[0])-5, y2: midY,
    stroke: family.color, 'stroke-width': 1.2, opacity: 0.28 }));

  // Connectors
  sorted.forEach((f, i) => {
    if (i === 0) return;
    const x1 = right(sorted[i-1]) + 1, x2 = left(f);
    svg.appendChild(mk('line', { x1, y1: midY, x2: x2-7, y2: midY,
      stroke: family.color, 'stroke-width': 1.2, opacity: 0.28 }));
    svg.appendChild(mk('polygon', {
      points: `${x2-7},${midY-3.5} ${x2},${midY} ${x2-7},${midY+3.5}`,
      fill: family.color, opacity: 0.38 }));
  });

  // Exit arrow
  const lastRight = right(sorted[sorted.length - 1]);
  svg.appendChild(mk('line', { x1: lastRight+1, y1: midY, x2: SVG_W-16, y2: midY,
    stroke: family.color, 'stroke-width': 1.2, opacity: 0.28 }));
  svg.appendChild(mk('polygon', {
    points: `${SVG_W-22},${midY-3.5} ${SVG_W-15},${midY} ${SVG_W-22},${midY+3.5}`,
    fill: family.color, opacity: 0.38 }));

  // Field boxes
  family.fields.forEach(f => {
    const cx = COLS[f.col].cx, bx = cx - f.w / 2;
    const g = document.createElementNS(ns, 'g');
    g.style.cursor = 'crosshair';

    const rect = mk('rect', { x: bx, y: boxY, width: f.w, height: BOX_H, rx: 5,
      fill: '#06090f', stroke: family.color,
      'stroke-width': f.opt ? 1.5 : 2,
      'stroke-dasharray': f.opt ? '5 3' : 'none',
      opacity: f.opt ? 0.82 : 1 });
    g.appendChild(rect);

    const label = mk('text', { x: cx, y: boxY + BOX_H/2 + 1,
      'text-anchor': 'middle', fill: family.color,
      'font-family': 'JetBrains Mono, Fira Code, monospace',
      'font-size': f.label.length > 15 ? 8 : 10,
      'font-weight': 700, opacity: f.opt ? 0.85 : 1 });
    label.textContent = f.label;
    g.appendChild(label);

    const sub = mk('text', { x: cx, y: boxY + BOX_H - 5,
      'text-anchor': 'middle', fill: family.color,
      'font-family': 'JetBrains Mono, Fira Code, monospace',
      'font-size': 7.5, opacity: 0.38 });
    sub.textContent = f.sub;
    g.appendChild(sub);

    if (f.opt) {
      const q = mk('text', { x: bx + f.w - 5, y: boxY + 10,
        'text-anchor': 'end', fill: family.color,
        'font-family': 'JetBrains Mono, Fira Code, monospace',
        'font-size': 8, opacity: 0.32 });
      q.textContent = '?';
      g.appendChild(q);
    }

    if (f.tip) {
      g.addEventListener('mouseenter', e => {
        rect.setAttribute('fill', family.bg);
        rect.setAttribute('stroke-width', 2);
        showTip(e, f.tip, family.color);
      });
      g.addEventListener('mousemove', moveTip);
      g.addEventListener('mouseleave', () => {
        rect.setAttribute('fill', '#06090f');
        rect.setAttribute('stroke-width', f.opt ? 1.5 : 2);
        hideTip();
      });
      g.addEventListener('click', e => {
        e.stopPropagation();
        togglePin(e, f.tip, family.color);
      });
    }
    svg.appendChild(g);
  });

  // Name + tag
  const nameEl = mk('text', { x: 14, y: midY - 5, fill: family.color,
    'font-family': 'JetBrains Mono, Fira Code, monospace',
    'font-size': 10.5, 'font-weight': 700 });
  nameEl.textContent = family.name;
  svg.appendChild(nameEl);

  const tagEl = mk('text', { x: 14, y: midY + 9, fill: family.color,
    'font-family': 'JetBrains Mono, Fira Code, monospace',
    'font-size': 7.5, opacity: 0.42 });
  tagEl.textContent = family.tag;
  svg.appendChild(tagEl);

  // Chevron (will be updated by toggle)
  const chevron = mk('text', { x: SVG_W - 14, y: midY + 4,
    'text-anchor': 'end', fill: '#1a2d42',
    'font-family': 'JetBrains Mono, Fira Code, monospace',
    'font-size': 11, opacity: 0.85 });
  chevron.textContent = '▼';
  chevron.dataset.role = 'chevron';
  svg.appendChild(chevron);

  return svg;
}

// ─── Examples panel builder ────────────────────────────────────────────────
function buildExamples(family) {
  const div = document.createElement('div');
  div.className = 'examples';
  div.style.background = '#07090f';
  div.style.border = `1px solid ${family.color}28`;
  div.style.borderTop = `2px solid ${family.color}`;

  const hdr = document.createElement('div');
  hdr.className = 'examples-header';

  const title = document.createElement('span');
  title.className = 'examples-title';
  title.style.color = family.color;
  title.textContent = family.name;
  hdr.appendChild(title);

  const closeBtn = document.createElement('button');
  closeBtn.className = 'close-btn';
  closeBtn.style.color = family.color;
  closeBtn.style.borderColor = family.color + '35';
  closeBtn.textContent = 'CLOSE ✕';
  closeBtn.onclick = e => { e.stopPropagation(); div.remove(); };
  hdr.appendChild(closeBtn);
  div.appendChild(hdr);

  family.examples.forEach(ex => {
    const block = document.createElement('div');
    block.className = 'example-block';

    const head = document.createElement('div');
    head.className = 'example-head';
    head.innerHTML = `<span class="example-mnemonic">${ex.mnemonic}</span>
                      <span class="example-asm">${ex.asm}</span>`;
    block.appendChild(head);

    const byteRow = document.createElement('div');
    byteRow.className = 'byte-row';

    ex.bytes.forEach(b => {
      const card = document.createElement('div');
      card.className = 'byte-card';

      const box = document.createElement('div');
      box.className = 'byte-box';
      box.style.borderColor = b.color + '50';

      const hex = document.createElement('span');
      hex.className = 'byte-hex';
      hex.style.color = b.color;
      hex.textContent = b.hex;
      box.appendChild(hex);

      const fl = document.createElement('div');
      fl.className = 'byte-field-label';
      fl.style.background = b.color + '15';
      fl.style.borderTopColor = b.color + '22';
      fl.style.color = b.color;
      fl.textContent = b.field;
      box.appendChild(fl);
      card.appendChild(box);

      const note = document.createElement('div');
      note.className = 'byte-note';
      note.textContent = b.note;
      card.appendChild(note);
      byteRow.appendChild(card);
    });

    const countPill = document.createElement('div');
    countPill.style.cssText = 'display:flex;align-items:flex-start;padding-top:8px;margin-left:6px';
    const pill = document.createElement('span');
    pill.className = 'byte-count';
    pill.style.background = family.color + '14';
    pill.style.borderColor = family.color + '28';
    pill.style.border = `1px solid ${family.color}28`;
    pill.style.color = family.color;
    pill.textContent = ex.bytes.length + ' byte(s)';
    countPill.appendChild(pill);
    byteRow.appendChild(countPill);

    block.appendChild(byteRow);
    div.appendChild(block);
  });

  return div;
}

// ─── Render ────────────────────────────────────────────────────────────────
const legendEl = document.getElementById('legend');
const container = document.getElementById('diagram-inner');

GROUPS.forEach(group => {
  // Legend item
  const li = document.createElement('div');
  li.className = 'legend-item';
  li.innerHTML = `<div class="legend-dot" style="background:${group.color}"></div>
                  <span class="legend-label" style="color:${group.color}">${group.label}</span>`;
  legendEl.appendChild(li);
});

let prevGroupId = null;

GROUPS.forEach(group => {
  group.families.forEach(family => {
    // Group separator
    if (prevGroupId && prevGroupId !== group.id) {
      const sep = document.createElement('div');
      sep.className = 'group-divider';
      sep.innerHTML = `<div class="line" style="background:${group.color}1a"></div>
                       <span class="label" style="color:${group.color}">${group.label}</span>
                       <div class="line" style="background:${group.color}1a"></div>`;
      container.appendChild(sep);
    }
    prevGroupId = group.id;

    // Row wrapper
    const wrap = document.createElement('div');
    wrap.className = 'row-wrap';

    const svgWrap = document.createElement('div');
    svgWrap.className = 'row-svg-wrap';
    svgWrap.style.minWidth = '820px';

    const svg = buildRowSVG(family);
    svgWrap.appendChild(svg);

    let open = false;

    svgWrap.addEventListener('click', () => {
      const chevron = svg.querySelector('[data-role="chevron"]');
      open = !open;
      if (open) {
        chevron.setAttribute('fill', family.color);
        chevron.textContent = '▲';
        wrap.appendChild(buildExamples(family));
      } else {
        chevron.setAttribute('fill', '#1a2d42');
        chevron.textContent = '▼';
        const panel = wrap.querySelector('.examples');
        if (panel) panel.remove();
      }
    });

    // Re-close when close button removes panel from outside toggle
    wrap.addEventListener('click', e => {
      if (!wrap.querySelector('.examples')) {
        open = false;
        const chevron = svg.querySelector('[data-role="chevron"]');
        if (chevron) {
          chevron.setAttribute('fill', '#1a2d42');
          chevron.textContent = '▼';
        }
      }
    });

    wrap.appendChild(svgWrap);
    container.appendChild(wrap);
  });
});
</script>
</body>
</html>
